
.add-branch-to-releaserc-script: &add-branch-to-releaserc-script-cfg
  >
  if [ -n "${MR_PRERELEASE+x}" ] && [ ${MR_PRERELEASE} == "yes" ]; then
    cp .releaserc.yml .releaserc.bak
    yq eval '.branches += {"name": "'"${CI_COMMIT_REF_NAME}"'", "prerelease": "pre.'"${CI_PIPELINE_ID}"'"}' .releaserc.bak > .releaserc.yml
  fi

.semantic-release-base:
  image: $CI_REGISTRY/autostore/ci/semantic-release:8-linux
  tags:
    - linux-docker

# This template will get the next version as seen by semantic-release. Subsequent jobs
# can use the `SEMANTIC_RELEASE_VERSION` variable to give as input to the build process.
.next-semantic-release-version:
  extends: .semantic-release-base
  stage: .pre
  script:
    - *add-branch-to-releaserc-script-cfg
    - npx semantic-release --dry-run --no-ci
    - >
      if [ -e .VERSION ]; then
        echo "SEMANTIC_RELEASE_VERSION=$(<.VERSION)" >> build.env
      else
        echo "SEMANTIC_RELEASE_VERSION=0.0.0" >> build.env
      fi
  artifacts:
    reports:
      dotenv: build.env

# This template will perform what is defined in .releaserc.yml if the conditions are met
# e.g., there is a new version to release based on the commits in the repository
#
# If `MR_PRERELEASE=yes`, it will perform the steps defined on an MR. Users of this, should
# always remember to rebase and drop the commit from semantic-release containing the
# `ChangeLog.md`
.semantic-release:
  extends: .semantic-release-base
  needs:
    - build
  stage: deploy
  script:
    - *add-branch-to-releaserc-script-cfg
    - |
      if [ -n "${MR_PRERELEASE+x}" ] && [ ${MR_PRERELEASE} == "yes" ]; then
        npx semantic-release --no-ci
      else
        npx semantic-release
      fi
