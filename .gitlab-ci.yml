.merge-request-rule: &merge-request-rule-cfg
  if: $CI_PIPELINE_SOURCE == "merge_request_event"

.push-branch-rule: &push-branch-rule-cfg
  if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH && $CI_PIPELINE_SOURCE == "push"

workflow:
  rules:
    # This line is to facilitate easier merging with the baseline
    - if: $CI_PROJECT_NAME == "rust-baseline"
      when: never
    - <<: *merge-request-rule-cfg
      variables:
        MR_PRERELEASE: "yes"
    - <<: *push-branch-rule-cfg

include:
  - "/.gitlab/rust.yml"
  - "/.gitlab/semantic-release.yml"

pre:next-semantic-release-version:
  extends: .next-semantic-release-version

build:linux:
  extends: .rust-linux-builder
  needs:
    - pre:next-semantic-release-version
  parallel:
    matrix:
      - OS: linux
        KIT: [musl,gnu]
        ARCH: [x86_64,aarch64]
  script:
    - |
      target=${ARCH}-unknown-${OS}-${KIT}
      cargo zigbuild --release --target=${target} --message-format=json 1> rustc-messages.json
      if [ $? -ne 0 ]; then
        jq -r 'select(.reason == "compiler-message") | .message | select(.level == "error" or .level == "warning") | .rendered' rustc-messages.json
        exit 1
      else
        jq -r 'select(.reason == "compiler-artifact" and .executable != null) | .executable' rustc-messages.json \
        | sed 's/ (bin)$//' | while IFS= read -r binary; do
            mkdir -p target/${target}/publish
            cp "$binary" target/${target}/publish
          done
      fi
  artifacts:
    paths:
      - target/${ARCH}-unknown-${OS}-${KIT}/publish

build:windows:
  extends: .rust-windows-builder
  needs:
    - pre:next-semantic-release-version
  parallel:
    matrix:
      - OS: windows
        KIT: [msvc]
        ARCH: [x86_64]
  script:
    - Invoke-WebRequest https://github.com/protocolbuffers/protobuf/releases/download/v28.0/protoc-28.0-win64.zip -OutFile .\protoc.zip
    - Expand-Archive .\protoc.zip .\
    - $env:PROTOC="$PWD\bin\protoc.exe"
    - |
      $ErrorActionPreference = "Stop"
      $target="${env:ARCH}-pc-${env:OS}-${env:KIT}"
      cargo build --release --target=${target} --message-format=json 1> rustc-messages.json
      if ($LASTEXITCODE -ne 0) {
        $messages = Get-Content rustc-messages.json | ForEach-Object {
            $json = $_ | ConvertFrom-Json
            if ($json.reason -eq "compiler-message" -and ($json.message.level -eq "error" -or $json.message.level -eq "warning")) {
                $json.message.rendered
            }
        }
        $messages | ForEach-Object { Write-Output $_ }
        exit 1
      } else {
        $binaries = Get-Content rustc-messages.json | ForEach-Object {
            $json = $_ | ConvertFrom-Json
            if ($json.reason -eq "compiler-artifact" -and $json.executable) {
                $json.executable
            }
        }
        foreach ($binary in $binaries) {
            $_ = New-Item -ItemType Directory -Path "target/${target}/publish" -Force
            $binary = $binary -replace ' \(bin\)$', ''
            Copy-Item $binary -Destination "target/${target}/publish"
        }
      }
  artifacts:
    paths:
      - target/${ARCH}-pc-${OS}-${KIT}/publish

test:test-and-coverage:
  extends: .test-and-coverage
  needs:
    - pre:next-semantic-release-version

test:sonar-scanner:
  extends: .sonar-scanner
  needs:
    - test:test-and-coverage

post:semantic-release:
  extends: .semantic-release
  needs:
    - build:linux
    - build:windows
    - test:sonar-scanner
  rules:
    - <<: *push-branch-rule-cfg
      when: always
